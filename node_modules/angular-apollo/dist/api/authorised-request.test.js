"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var authorised_request_1 = require("./authorised-request");
var Rx_1 = require("rxjs/Rx");
var i_spy_1 = require("i-spy");
var auth_tokens_validator_1 = require("../token-management/auth-tokens-validator");
var failWith = function (msg) { return fail.bind(null, msg); };
describe('SecureRequest', function () {
    var tokenStore, tokens, fakeTokenValidator, whenAuthorised;
    beforeEach(function () {
        tokens = {
            authToken: 'fake-auth-token',
            refreshToken: 'fake-refresh-token',
            hasBeenRefreshed: false
        };
        tokenStore = {
            get: function () { return Rx_1.Observable.from([tokens]); },
            events: new Rx_1.Subject()
        };
        fakeTokenValidator = { validateTokens: function () { return Rx_1.Observable.from([tokens]); } };
        whenAuthorised = i_spy_1.createSpy(function () { return Rx_1.Observable.from([{}]); });
    });
    describe('when a token exists', function () {
        it('the callback is called', function (done) {
            new authorised_request_1.SecureRequest(tokenStore, fakeTokenValidator)
                .authorisedRequest({}, whenAuthorised)
                .subscribe(function () {
                expect(whenAuthorised.wasCalled()).toBe(true);
                done();
            });
        });
    });
    describe('when the token is missing', function () {
        beforeEach(function () { return tokens = null; });
        it('errors saying there is a token missing', function (done) {
            tokenStore.events.subscribe(failWith('got an event'), function (err) {
                expect(err.missingTokens).toEqual(true);
                done();
            });
            new authorised_request_1.SecureRequest(tokenStore, null)
                .authorisedRequest(null, function () { return Rx_1.Observable.from([]); })
                .subscribe(failWith('got request success'), failWith('got request error'));
        });
        it('it returns nothing if the token is missing', function (done) {
            new authorised_request_1.SecureRequest(tokenStore, null)
                .authorisedRequest(null, function () { return Rx_1.Observable.from([]); })
                .subscribe(failWith('got request success'), failWith('got request error'), done);
        });
    });
    [new auth_tokens_validator_1.AuthenticationError({}), { status: 403 }].forEach(function (error) {
        describe('when token validation fails', function () {
            beforeEach(function () {
                return fakeTokenValidator.validateTokens =
                    function () { return Rx_1.Observable.throw(error); };
            });
            it('emits an api authorisation error', function (done) {
                tokenStore.events.subscribe(failWith('got event'), function (err) {
                    expect(err.invalidAuthToken).toEqual(true);
                    done();
                });
                new authorised_request_1.SecureRequest(tokenStore, fakeTokenValidator)
                    .authorisedRequest({}, whenAuthorised)
                    .subscribe(failWith('got request success'), failWith('got request error'));
            });
            it('returns an empty observable', function (done) {
                new authorised_request_1.SecureRequest(tokenStore, fakeTokenValidator)
                    .authorisedRequest({}, whenAuthorised)
                    .subscribe(failWith('got request success'), failWith('got request error'), done);
            });
        });
    });
    describe('when the authorised request fails', function () {
        var apiErr;
        beforeEach(function () {
            apiErr = new Error('plop');
            whenAuthorised = function () { return Rx_1.Observable.throw(apiErr); };
        });
        it('doesn\'t emit an error', function (done) {
            tokenStore.events.subscribe(failWith('got an event'), failWith('got an error event'));
            new authorised_request_1.SecureRequest(tokenStore, fakeTokenValidator)
                .authorisedRequest({}, whenAuthorised)
                .subscribe(failWith('got request success'), function (err) {
                expect(err).toEqual(apiErr);
                done();
            });
        });
    });
    describe('when the token is refreshed', function () {
        beforeEach(function () { return tokens.hasBeenRefreshed = true; });
        it('pushes a validated token event', function (done) {
            tokenStore.events.subscribe(function (newTokens) {
                expect(newTokens).toEqual(tokens);
                done();
            }, failWith('got error event'));
            new authorised_request_1.SecureRequest(tokenStore, fakeTokenValidator)
                .authorisedRequest({}, whenAuthorised)
                .subscribe();
        });
        it('calls the callback', function (done) {
            new authorised_request_1.SecureRequest(tokenStore, fakeTokenValidator)
                .authorisedRequest({}, whenAuthorised)
                .subscribe(function () { }, function () { }, function () {
                expect(whenAuthorised.wasCalled()).toBe(true);
                done();
            });
        });
    });
});
//# sourceMappingURL=authorised-request.test.js.map