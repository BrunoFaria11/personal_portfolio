"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var http_1 = require("@angular/http");
var testing_1 = require("@angular/core/testing");
var testing_2 = require("@angular/http/testing");
var auth_tokens_validator_1 = require("./auth-tokens-validator");
var authorisation_tokens_1 = require("./authorisation-tokens");
var stubApiBaseUrl = 'http://example.com';
describe('auth tokens validator', function () {
    function generateTestToken(expiry) {
        if (expiry === void 0) { expiry = null; }
        var token = {
            exp: expiry || (Date.now() / 1000) + 3
        };
        var tokenPayload = btoa(JSON.stringify(token));
        return "fakeHeader." + tokenPayload + ".signature";
    }
    function stubResponse(mockBackend, expiredTokens, response) {
        mockBackend.connections.subscribe(function (connection) {
            expect(connection.request.url).toBe(stubApiBaseUrl + "/auth/refresh");
            expect(JSON.parse(connection.request.getBody()))
                .toEqual({ refresh_token: expiredTokens.refreshToken });
            expect(connection.request.headers.getAll('Authorization'))
                .toEqual(["bearer " + expiredTokens.authToken]);
            expect(connection.request.headers.getAll('Content-Type'))
                .toEqual(['application/json']);
            connection.mockRespond(new http_1.Response(new http_1.ResponseOptions(response)));
        });
    }
    beforeEach(function () {
        testing_1.TestBed.configureTestingModule({
            providers: [
                testing_2.MockBackend,
                http_1.BaseRequestOptions,
                {
                    provide: http_1.Http,
                    useFactory: function (backend, options) { return new http_1.Http(backend, options); },
                    deps: [testing_2.MockBackend, http_1.BaseRequestOptions]
                },
                {
                    provide: auth_tokens_validator_1.JwtAuthTokensValidator,
                    useFactory: function (http) {
                        return new auth_tokens_validator_1.JwtAuthTokensValidator(http, stubApiBaseUrl);
                    },
                    deps: [http_1.Http]
                }
            ]
        });
    });
    it('returns unrefreshed tokens when auth token is valid', testing_1.async(testing_1.inject([auth_tokens_validator_1.JwtAuthTokensValidator], function (authTokensValidator) {
        var expectedTokens = new authorisation_tokens_1.AuthorisationTokens(generateTestToken(), 'refresh-token');
        authTokensValidator.validateTokens(expectedTokens.authToken, expectedTokens.refreshToken)
            .subscribe(function (validatedTokens) { return expect(validatedTokens).toEqual(expectedTokens); }, fail);
    })));
    it('returns missing token error when auth token is missing', testing_1.async(testing_1.inject([auth_tokens_validator_1.JwtAuthTokensValidator], function (authTokensValidator) {
        authTokensValidator.validateTokens(null, 'refresh token').subscribe(function () { return fail(new Error('Expected validation error')); }, function (err) { return expect(err.missingToken).toEqual(true); });
    })));
    it('returns bad token error when auth token is not a jwt', testing_1.async(testing_1.inject([auth_tokens_validator_1.JwtAuthTokensValidator], function (authTokensValidator) {
        authTokensValidator.validateTokens('asdf', 'refresh token').subscribe(function () { return fail(new Error('Expected validation error')); }, function (err) { return expect(err.badToken).toEqual(true); });
    })));
    it('returns refreshed tokens when auth token has expired', testing_1.async(testing_1.inject([testing_2.MockBackend, auth_tokens_validator_1.JwtAuthTokensValidator], function (mockBackend, authTokensValidator) {
        var refreshTokenResponse = {
            status: 200,
            body: {
                access_token: 'newAuthToken',
                refresh_token: 'newRefreshToken'
            }
        };
        var expiredTokens = {
            authToken: generateTestToken(Date.now() / 1000),
            refreshToken: 'refresh-token'
        };
        stubResponse(mockBackend, expiredTokens, refreshTokenResponse);
        authTokensValidator.validateTokens(expiredTokens.authToken, expiredTokens.refreshToken)
            .subscribe(function (validatedTokens) {
            expect(validatedTokens).toEqual(new authorisation_tokens_1.AuthorisationTokens(refreshTokenResponse.body.access_token, refreshTokenResponse.body.refresh_token, true));
        }, fail);
    })));
    it('returns not authorised error when token refresh returns bad status code', testing_1.async(testing_1.inject([testing_2.MockBackend, auth_tokens_validator_1.JwtAuthTokensValidator], function (mockBackend, authTokensValidator) {
        var refreshTokenResponse = { status: 500 };
        var expiredTokens = {
            authToken: generateTestToken(Date.now() / 1000),
            refreshToken: 'refresh-token'
        };
        stubResponse(mockBackend, expiredTokens, refreshTokenResponse);
        authTokensValidator.validateTokens(expiredTokens.authToken, expiredTokens.refreshToken).subscribe(function () { return fail(new Error('Expected validation error')); }, function (err) { return expect(err.message).toEqual('Bad status code: 500'); });
    })));
    it('is not authorised when token refresh endpoint errors', testing_1.async(testing_1.inject([testing_2.MockBackend, auth_tokens_validator_1.JwtAuthTokensValidator], function (mockBackend, authTokensValidator) {
        var authToken = generateTestToken(Date.now() / 1000);
        mockBackend.connections.subscribe(function (connection) {
            connection.mockError(new Error('a test error'));
        });
        authTokensValidator.validateTokens(authToken, 'refresh token').subscribe(function () { return fail(new Error('Expected validation error')); }, function (err) { return expect(err.message).toEqual('a test error'); });
    })));
});
//# sourceMappingURL=auth-tokens-validator.test.js.map